C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/22/2019 16:10:15 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE ST7735_TFT
OBJECT MODULE PLACED IN .\Objects\st7735_TFT.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil_v5\C51\BIN\C51.EXE st7735_TFT.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEX
                    -TEND PRINT(.\Listings\st7735_TFT.lst) TABS(2) OBJECT(.\Objects\st7735_TFT.obj)

line level    source

   1          #include <BasicSet.c>
   2          #define TFT_Width       128
   3          #define TFT_Height      160
   4          
   5          unsigned int xdata Area[20];          //×·×Ù±³¾°
   6          unsigned int xdata groundx[20];       //±³¾°
   7          unsigned char data trackSquare[6];    //×·×ÙÇøÓò
   8          unsigned char data tetris[5] = {0x00,0x06,0x04,0x04,0};       //µÍËÄÎ»´æÐÐÊý¾Ý
   9          unsigned char count = 1, Down_Flag = 0, Move_flag = 0;        //¶¨Ê±Æ÷T0¼ÆÊýÎ»£¬ÏÂ½µºÍÒÆ¶¯±êÖ¾
  10          unsigned char square_x = 3, square_y = 0, rotate = 0;         //³õÊ¼Î»ÖÃ£¬Ðý×ªÎ»ÖÃ
  11          unsigned int code tetrisData[6][4] = {                        //·½¿éÊý¾Ý
  12            {0x0c88,0x08e0,0x0226,0x0e20},
  13            {0x06c0,0x08c4,0x06c0,0x08c4},
  14            {0x0c60,0x04c8,0x0c60,0x04c8},
  15            {0x088c,0x02e0,0x0622,0x0e80},
  16            {0x0e40,0x0464,0x04e0,0x04c4},
  17            {0x0660,0x0660,0x0660,0x0660}
  18          };
  19          unsigned int code *pTetris = tetrisData[0];    //·½¿éÖ¸Õë
  20          unsigned int code *PTimer;    //Ëæ»úÖ¸Õë
  21          unsigned char tcount = 0;     //T1¼ÆÊýÎ»
  22          sbit Left = P1^3;             //°´¼ü
  23          sbit Right = P1^2;
  24          sbit Rota = P1^1;
  25          sbit fast = P1^0;
  26          void fillRectangle(unsigned char x, unsigned char y, unsigned char w, unsigned char h, unsigned int color)
             -{
  27   1        if((x >= TFT_Width) || (y >= TFT_Height))
  28   1          return;
  29   1        if((x + w - 1) >= TFT_Width)
  30   1          w = TFT_Width  - x;
  31   1        if((y + h - 1) >= TFT_Height)
  32   1          h = TFT_Height - y;
  33   1        Lcd_SetRegion(x, y, x+w-1, y+h-1);
  34   1        for(y = h; y > 0; y--) {
  35   2          for(x = w; x > 0; x--) {
  36   3            Lcd_WriteData_16(color);
  37   3          }
  38   2        }
  39   1      }
  40          // 8X8 square
  41          void fillPoint(unsigned char x, unsigned char y, unsigned int color ) {
  42   1        unsigned char i;
  43   1        x *= 8;
  44   1        y *= 8;
  45   1        Lcd_SetRegion(x, y, x+7, y+7);
  46   1        for(i = 64; i > 0; i-- )
  47   1          Lcd_WriteData_16(color);
  48   1      }
  49          
  50          //Êý¾Ý´¢´æ½á¹¹£ºÒ»¸ö16Î»intÀàÐÍ´ú±íÒ»ÐÐ
  51          //¸ßÎ»Îª1´ú±í×óÇ½±Ú£¬µÍÈýÎ»ÖÃ1´ú±íÓÒÇ½±Ú
  52          /*  Ç½    1  2  3  4  5  6  7  8  9  10 11   Ç½14
  53              11 |  x  x  x  x  x  x  x  x  x  x  x  | 111      0xc007
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/22/2019 16:10:15 PAGE 2   

  54          */
  55          void trackSquare_Read(unsigned char x, unsigned char y){
  56   1        unsigned int xdata *p = Area;
  57   1        unsigned char i;
  58   1        p += y;           //Êý¾Ý¿ªÊ¼ÐÐ
  59   1        for(i = 0; i < 6; i++){
  60   2          trackSquare[i] = (*p >> (9-x)); //È¡³ö6Î»Êý¾Ý£¬ÓÒÒÆ 14-6+1-x=9-x
  61   2          p++;
  62   2        }
  63   1      }
  64          
  65          void trackSquare_Write(unsigned char x, unsigned char y){
  66   1        unsigned int xdata *p = Area;
  67   1        unsigned char i;
  68   1        unsigned int a, and = 0x003f;         //  µÍÁùÎ»ÖÃ1
  69   1        p += y;
  70   1        and <<= (9-x);                        //×óÒÆ¶ÔÎ»
  71   1        for(i = 0; i < 6; i++ ){
  72   2          a = trackSquare[i] << (9-x);
  73   2          *p &= ~and;                         //È¡·´ÏàÓë£¬Çå¿ÕAreaÖÐµÄtracksquareÇøÓò
  74   2          *p |= a;                            //Óë ÐÂµÄÊý¾Ý
  75   2          p++;
  76   2        }
  77   1      
  78   1      }
  79          void tetris_Storage(unsigned char x, unsigned char y, unsigned char *p){
  80   1        unsigned int xdata *pgroundx = groundx;
  81   1        unsigned char i;
  82   1        unsigned int a;
  83   1        pgroundx += (y);
  84   1        for(i = 0; i < 6; i++ ){
  85   2          a = *p & 0x3f;                   //ÆÁ±Î¸ßÁ½Î»
  86   2          a <<= (9-x);
  87   2          *pgroundx |= a;                  //Ð´ÈëÉÏÒ»´ÎtracksquareÖÐµÄÊý¾Ý
  88   2          p++;
  89   2          pgroundx++;
  90   2        }
  91   1      /*  a = 0x8000;                     //debug
  92   1        for(i = 0; i < 16;i++){
  93   1          if(groundx[16] & a)
  94   1            fillPoint(i, 0, RED);
  95   1          a >>= 1;
  96   1        }
  97   1      */
  98   1      }
  99          
 100          //Show trackSquare
 101          unsigned char showTrackSquare_Down(unsigned char x, unsigned char y, unsigned char direction){
 102   1        signed char i,j;
 103   1        unsigned char data temptrack[6],aa[6];
 104   1        unsigned char data *pTrack =trackSquare;
 105   1        unsigned char data *pTemp = temptrack;
 106   1        unsigned char row;
 107   1        unsigned int  row_int;
 108   1        for(i = 0; i < 6; i++)
 109   1          temptrack[i] = *pTrack++; //ÉÏ´Î¼ÇÂ¼Êý¾ÝÔÝ´æ
 110   1      
 111   1        for(i = 0; i < 6; i++)
 112   1          trackSquare[i] = groundx[y+i] >> (9-x) & 0x3f; //±³¾°Êý¾ÝÐ´Èëtracksquare
 113   1      
 114   1        if(direction == 0)                               //ÏÂ½µ
 115   1          for(i = 0; i < 4; i++){
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/22/2019 16:10:15 PAGE 3   

 116   2            row = tetris[i] << 1;
 117   2            if(tetris[i+1] & trackSquare[4-i] >> 1){    //tracksquare µÍ6Î»ÖÐ¼ä4Î»±£´æÊý¾Ý£¬¶øteterisµÍËÄÎ»±£´æÊ
             -ý¾Ý£¬ ÓÒÒÆÒ»Î»
 118   3              tetris_Storage(x,y,temptrack);            //ÅÐ¶ÏÊÇ·ñ´¥µ×£¬TetrisµÚ1ÐÐÓëtracksquareµÚ4ÐÐ¶ÔÎ»ÅÐ¶Ï
 119   3              square_y = 0;     //³õÊ¼»¯y×ø±ê
 120   3              square_x = 3;     //³õÊ¼»¯x×ø±ê
 121   3              pTetris = PTimer; //¶¨Ê±Æ÷Ëæ»úÖ¸Õë¸³Öµ¸øpTetris
 122   3              row_int = *pTetris;
 123   3              for(i = 0; i < 4; i++){
 124   4                tetris[3-i] = row_int & 0x0f;            //ÆÁ±Î¸ßÎ»£¬½«Êý¾ÝÐ´Èëtetris
 125   4                row_int >>= 4;
 126   4              }
 127   3              return 1;
 128   3            }
 129   2            trackSquare[5-i] |= row;                     //trackÇøÓòÓë¶íÂÞË¹·½¿éÏà»ò,±£´æÕâ´ÎÒÆ¶¯²Ù×÷µÄÊý¾Ý
 130   2          }
 131   1        else
 132   1          if(direction == 1)                             //×óÒÆ
 133   1            for(i = 0; i < 4; i++){
 134   2              row = tetris[i] << 2;
 135   2              if(tetris[i] & trackSquare[4-i] >> 2)
 136   2                return 1;
 137   2              trackSquare[4-i] |= row;
 138   2            }
 139   1          else
 140   1            if(direction == 2)                           //ÓÒÒÆ
 141   1              for(i = 0; i < 4; i++){
 142   2                row = tetris[i];
 143   2                if(tetris[i] & trackSquare[4-i])
 144   2                  return 1;
 145   2                trackSquare[4-i] |= row;
 146   2              }
 147   1            else
 148   1              if(direction == 3){                        //Ðý×ª
 149   2                row_int = *(pTetris + rotate);
 150   2                rotate++;
 151   2                if(rotate > 3)
 152   2                  rotate = 0;
 153   2                for(i = 0; i < 4; i++){
 154   3                  tetris[3-i] = row_int & 0x0f;          //ÆÁ±Î¸ßÎ»£¬½«Êý¾ÝÐ´Èëtetris
 155   3                  row_int >>= 4;
 156   3                }
 157   2                for(i = 0; i < 4; i++){
 158   3                  row = tetris[i] << 1;
 159   3                  if(tetris[i] & trackSquare[4-i] >> 1){ //ÅÐ¶ÏÊÇ·ñ¿ÉÒÔÐý×ª£¬¶ÔÓ¦ÐÐÏàÓë
 160   4                    rotate--;
 161   4                    row_int = *(pTetris + rotate);
 162   4                    for(i = 0; i < 4; i++){
 163   5                      tetris[3-i] = row_int & 0x0f;      //ÓëÖµÎªÕæ·µ»ØÇ°Ò»´ÎµÄÊý¾Ý
 164   5                      row_int >>= 4;
 165   5                    }
 166   4                    return 1;
 167   4                  }
 168   3                  trackSquare[4-i] |= row;
 169   3                }
 170   2              }
 171   1              else
 172   1                return 1;
 173   1        pTemp = &temptrack[0];
 174   1        pTrack = trackSquare;
 175   1        for(i = 0; i < 6; i++){
 176   2          aa[i] = *pTrack ^ *pTemp;
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/22/2019 16:10:15 PAGE 4   

 177   2          pTrack++;
 178   2          pTemp++;                               //Òì»òµÃµ½¸Ä±äÎ»´æÈëaa
 179   2        }
 180   1      
 181   1        for(i = 0; i < 6; i++){                 //ÖðÐÐÉ¨Ãè
 182   2          if(aa[i]){                            //Òì»òÖµÎªÕæ£¬¸Ä±äÑÕÉ«
 183   3            row = 0x20;
 184   3            for(j = 0; j < 6; j++){             //ÐÐÄÚÉ¨Ãè
 185   4              if(aa[i] & row ){                 //°´Î»ÅÐ¶Ï
 186   5                if(temptrack[i] & row)          //Ô­À´µÄÖµÎªÕæ£¬¸Ä³É±³¾°É«£¨ºÚÉ«£©£¬·ñÔòÌî³äÑÕÉ«
 187   5                  fillPoint(x+j+1,y+i,BLACK);
 188   5                else
 189   5                  fillPoint(x+j+1,y+i,RED);
 190   5              }
 191   4              row >>= 1;
 192   4            }
 193   3          }
 194   2        }
 195   1        return 0;
 196   1      }
 197          
 198          //Ò»ÐÐÌîÂúÏû³ý
 199          void tetris_Clear(void)
 200          {
 201   1        unsigned int xdata *pRead = groundx;
 202   1        unsigned int xdata *pWrite;
 203   1        unsigned int xdata groundx_bak[20],aa[20];
 204   1        unsigned char i,co = 0;
 205   1        unsigned int row_int;
 206   1        for(i = 0; i < 20; i++)
 207   1          groundx_bak[i] = *pRead++;
 208   1        pRead = &groundx_bak[18];     //Ö¸Ïòµ¹ÊýµÚ2ÐÐ,¶ÁÈ¡bakÊý¾Ý
 209   1        pWrite = &groundx[18];        //Ö¸Ïòµ¹ÊýµÚ2ÐÐ£¬Ð´Èëgroundx
 210   1        for(i = 0; i < 18; i++){
 211   2          if(*pRead == 0xffff)
 212   2            pRead--;                  //Ìø¹ýÕâÒ»ÐÐ
 213   2          *pWrite = *pRead;           //Ð´ÈëÊý¾Ý
 214   2          if(*pRead == 0)
 215   2            *pWrite = 0;
 216   2          pRead--;
 217   2          pWrite--;
 218   2        }
 219   1        if(pRead == pWrite)
 220   1          return;                           //Ö¸ÏòµØÖ·ÏàÍ¬£¬·µ»Ø
 221   1        pRead = groundx;                    //Ïû³ý0xffffºóµÄÊý¾Ý
 222   1        pWrite = groundx_bak;
 223   1        for(i = 0; i < 20; i++)
 224   1          aa[i] = *pRead++ ^ *pWrite++;     //Òì»òÖµ´æÈëaa,pwrite
 225   1        pRead = groundx_bak;
 226   1        pWrite = aa;
 227   1        for(i = 0; i < 20; i++){            //ÐÐÉ¨Ãè
 228   2          if(*pWrite){                      //¿ÕÐÐÅÐ¶Ï
 229   3            row_int = 0x8000;
 230   3            for(co = 0; co < 20; co++){     //ÁÐÉ¨Ãè
 231   4              if(*pWrite & row_int){        //Òì»òÖµÎªÕæ£¬¸Ä±äÊý¾Ý
 232   5                if(*pRead & row_int)        //Ô­À´ÊÇ1¸Ä³ÉºÚÉ«£¬Ô­À´ÊÇ0¸Ä³ÉºìÉ«
 233   5                fillPoint(co, i, BLACK);
 234   5                else
 235   5                fillPoint(co, i, RED);
 236   5              }
 237   4            row_int >>= 1;
 238   4            }
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/22/2019 16:10:15 PAGE 5   

 239   3          }
 240   2          pWrite++;
 241   2          pRead++;
 242   2        }
 243   1      }
 244          
 245          
 246          void main(void)
 247          {
 248   1        unsigned char i;
 249   1        PT0 = 1;
 250   1        TMOD = 0x11;
 251   1        TH0 = 0x3C;
 252   1        TL0 = 0xB0;
 253   1        TH1 = 0xa6;
 254   1        TL1 = 0x28;
 255   1        EA = 1;
 256   1        ET0 = 1;
 257   1        ET1 = 1;
 258   1        TR0 = 1;                  //´ò¿ª¶¨Ê±Æ÷0£¬¶¨Ê±50ms
 259   1        TR1 = 1;                  //´ò¿ªT1£¬¶¨Ê±23ms
 260   1        P1 = 0x0f;                //¾ØÕó¼üÅÌ½ÓP1¿Ú£¬¸³³õÖµ
 261   1        for(i = 0; i < 20; i++){  //×óÓÒ±ß½ç
 262   2          groundx[i] = 0xc007;
 263   2          Area[i]=0xc007;
 264   2        }
 265   1        groundx[19] = 0xffff;     //ÏÂ±ß½ç
 266   1        Area[19] = 0xffff;
 267   1        lcd_initial();            //Òº¾§ÆÁ³õÊ¼»¯
 268   1        bl=1;                     //±³¹â²ÉÓÃIO¿ØÖÆ£¬Ò²¿ÉÒÔÖ±½Ó½Óµ½¸ßµçÆ½³£ÁÁ
 269   1        //»æ³öÓÎÏ·ÇøÓò
 270   1        LCD_Clear(BLACK);         //ºÚÉ«±³¾°
 271   1        fillRectangle(0,0,16,160,BLUE);
 272   1        fillRectangle(0,152,128,8,BLUE);
 273   1        fillRectangle(104,0,24,160,BLUE);
 274   1        delay(500);
 275   1      
 276   1        while(1)
 277   1        {
 278   2          if(Down_Flag){                                      //downflag¶¨Ê±Æ÷T0¼ÆÊ±1.5s´¥·¢ÖÃÎ»£¬·½¿éÏÂ½µ
 279   3            trackSquare_Read(square_x,square_y);              //¶ÁÈ¡×·×ÙÇøÓòÊý¾Ýµ½Tracksquare
 280   3            if(!showTrackSquare_Down(square_x, square_y, 0)){ //ÅÐ¶ÏÊÇ·ñ´¥µ×£¬´¥µ×Ôò²»Ð´Èë×·×ÙÊý¾Ý£¬ÓÉ¸Ãº¯Êý½«Êý
             -¾ÝÐ´Èë±³¾°ÇøÓò
 281   4              trackSquare_Write(square_x,square_y);           //Ã»ÓÐ´¥µ×£¬TracksquareÊý¾ÝÐ´Èë×·×ÙÇøÓò
 282   4              square_y++;                   //ÏÂÒÆÒ»¸ñ
 283   4            }
 284   3            else{
 285   4              tetris_Clear();             //Ïû³ý
 286   4              for(i = 0; i < 20; i++)
 287   4              Area[i]=groundx[i];         //Í¬²½Êý¾Ý
 288   4            }
 289   3            Down_Flag = 0;                //Çå³ýÏÂ½µ±êÖ¾
 290   3          }
 291   2          if(!Left && Move_flag){         //×óÒÆÅÐ¶Ï£¬Í¬Ê±ÅÐ¶ÏÊÇ·ñÔÊÐíÒÆ¶¯²Ù×÷£¬moveflagÓÉT0¿ØÖÆ
 292   3            delay(20);
 293   3            if(!Left){                    //ÑÓÊ±Ïû¶¶£¬ÔÙ´ÎÅÐ¶Ï
 294   4              trackSquare_Read(square_x,square_y);
 295   4              if(!showTrackSquare_Down(square_x, square_y, 1)){
 296   5                trackSquare_Write(square_x,square_y);
 297   5                square_x--;
 298   5              }
 299   4            }
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/22/2019 16:10:15 PAGE 6   

 300   3          }
 301   2          if(!Right && Move_flag){        //ÓÒÒÆÅÐ¶Ï
 302   3            delay(20);
 303   3            if(!Right){
 304   4              trackSquare_Read(square_x,square_y);
 305   4              if(!showTrackSquare_Down(square_x, square_y, 2)){
 306   5                trackSquare_Write(square_x,square_y);
 307   5                square_x++;
 308   5              }
 309   4            }
 310   3          }
 311   2          if(!Rota && Move_flag){        //Ðý×ªÅÐ¶Ï
 312   3            delay(20);
 313   3            if(!Rota){
 314   4              trackSquare_Read(square_x,square_y);
 315   4              if(!showTrackSquare_Down(square_x, square_y, 3))
 316   4                trackSquare_Write(square_x,square_y);
 317   4            }
 318   3          }
 319   2          if(!fast){                    //¼ÓËÙÏÂ½µ
 320   3            delay(20);
 321   3            if(!fast)
 322   3              Down_Flag = 1;
 323   3          }
 324   2        }
 325   1      
 326   1      }
 327          
 328          void Timer0() interrupt 1
 329          {
 330   1        TH0 = 0x3C;
 331   1        TL0 = 0xB0;                //¶¨Ê±50ms
 332   1        count++;
 333   1        if(count <= 22)           //Ç°22*50=1.1s¿ÉÒÔ½øÐÐ×óÓÒÒÆ¶¯²Ù×÷
 334   1          Move_flag = 1;
 335   1        else
 336   1          Move_flag = 0;
 337   1      
 338   1        if(count >= 30){          //¶¨Ê±1.5s
 339   2          count = 0;
 340   2          Down_Flag = 1;
 341   2        }
 342   1      }
 343          
 344          void Timer1() interrupt 3
 345          {
 346   1        TH1 = 0xa6;
 347   1        TL1 = 0x28;
 348   1        if(tcount > 5)
 349   1          tcount = 0;
 350   1        PTimer = tetrisData[tcount];
 351   1        tcount++;
 352   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3164    ----
   CONSTANT SIZE    =     48    ----
   XDATA SIZE       =     80      80
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22      64
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/22/2019 16:10:15 PAGE 7   

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
