C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 15:10:17 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE ST7735_TFT
OBJECT MODULE PLACED IN .\Objects\st7735_TFT.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil_v5\C51\BIN\C51.EXE st7735_TFT.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEX
                    -TEND PRINT(.\Listings\st7735_TFT.lst) TABS(2) OBJECT(.\Objects\st7735_TFT.obj)

line level    source

   1          #include <BasicSet.c>
   2          #define TFT_Width       128
   3          #define TFT_Height      160
   4          
   5          unsigned int xdata Area[20];
   6          unsigned int xdata groundx[20];
   7          unsigned char data trackSquare[6];
   8          unsigned char data tetris[5] = {0x00,0x0c,0x08,0x8,0};       //µÍËÄÎ»´æÐÐÊý¾Ý
   9          unsigned char count = 1, Down_Flag = 0, Move_flag = 0;
  10          unsigned char square_x = 6, square_y = 0;
  11          sbit Left = P1^3;
  12          sbit Right = P1^2;
  13          void fillRectangle(unsigned char x, unsigned char y, unsigned char w, unsigned char h, unsigned int color)
             -{
  14   1        if((x >= TFT_Width) || (y >= TFT_Height))
  15   1          return;
  16   1        if((x + w - 1) >= TFT_Width)
  17   1          w = TFT_Width  - x;
  18   1        if((y + h - 1) >= TFT_Height)
  19   1          h = TFT_Height - y;
  20   1        Lcd_SetRegion(x, y, x+w-1, y+h-1);
  21   1        for(y = h; y > 0; y--) {
  22   2          for(x = w; x > 0; x--) {
  23   3            Lcd_WriteData_16(color);
  24   3          }
  25   2        }
  26   1      }
  27          // 8X8 square
  28          void fillPoint(unsigned char x, unsigned char y, unsigned int color ) {
  29   1        unsigned char i;
  30   1        x *= 8;
  31   1        y *= 8;
  32   1        Lcd_SetRegion(x, y, x+7, y+7);
  33   1        for(i = 64; i > 0; i-- )
  34   1          Lcd_WriteData_16(color);
  35   1      }
  36          //ÏÔÊ¾¶íÂÞË¹·½¿é
  37          void print_Tetris(unsigned char x, unsigned char y, unsigned int cube, unsigned int color){
  38   1        unsigned char row, i,bit_row,j;
  39   1        for(i = 0; i < 4; i++){               //4ÐÐ
  40   2          row = cube & 0x0f;                  //È¡³öµÍ4Î»±£´æÔÚrowÖÐ
  41   2          cube >>= 4;
  42   2          bit_row = 0x08;
  43   2          for(j=0; j < 4; j++){
  44   3            if(row & bit_row)                 //°´Î»ÅÐ¶Ï£¬ÏÔÊ¾Ò»ÐÐ
  45   3              fillPoint(x+j,y+3-i,color);     //ÏÈÏÔÊ¾Êý¾ÝµÄµÍ4Î»£¬yÖµ·´¶ø×î´ó
  46   3            bit_row >>= 1;
  47   3          }
  48   2        }
  49   1      }
  50          
  51          //Êý¾Ý´¢´æ½á¹¹£ºÒ»¸ö16Î»intÀàÐÍ´ú±íÒ»ÐÐ
  52          //¸ßÎ»Îª1´ú±í×óÇ½±Ú£¬µÍÈýÎ»ÖÃ1´ú±íÓÒÇ½±Ú
  53          /*  Ç½    1  2  3  4  5  6  7  8  9  10 11   Ç½14
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 15:10:17 PAGE 2   

  54              11 |  x  x  x  x  x  x  x  x  x  x  x  | 111      0xc007
  55          */
  56          void trackSquare_Read(unsigned char x, unsigned char y){
  57   1        unsigned int xdata *p = Area;
  58   1        unsigned char i;
  59   1        p += y;           //Êý¾Ý¿ªÊ¼ÐÐ
  60   1        for(i = 0; i < 6; i++){
  61   2          trackSquare[i] = (*p >> (9-x)) & 0x3f; //È¡³ö6Î»Êý¾Ý£¬ÓÒÒÆ 14-6+1-x=9-x
  62   2          p++;
  63   2        }
  64   1      }
  65          
  66          void trackSquare_Write(unsigned char x, unsigned char y){
  67   1        unsigned int xdata *p = Area;
  68   1        unsigned char i;
  69   1        unsigned int a;
  70   1        p += y;
  71   1        for(i = 0; i < 6; i++ ){
  72   2          a = trackSquare[i];
  73   2          a <<= (9-x);
  74   2          *p = a;
  75   2          p++;
  76   2        }
  77   1      
  78   1      }
  79          void tetris_Storage(unsigned char x, unsigned char y, unsigned char *p){
  80   1        unsigned int xdata *pgroundx = groundx;
  81   1        unsigned char i;
  82   1        unsigned int a;
  83   1        pgroundx += (y);
  84   1        for(i = 0; i < 6; i++ ){
  85   2          a = *p & 0x3f;                   //ÆÁ±Î¸ßÁ½Î»
  86   2          a <<= (9-x);
  87   2          *pgroundx |= a;                  //Ð´ÈëÉÏÒ»´ÎtracksquareÖÐµÄÊý¾Ý
  88   2          p++;
  89   2          pgroundx++;
  90   2        }
  91   1        a = 0x8000;
  92   1        for(i = 0; i < 16;i++){
  93   2          if(groundx[16] & a)
  94   2            fillPoint(i, 0, RED);
  95   2          a >>= 1;
  96   2        }
  97   1      
  98   1      }
  99          
 100          //Show trackSquare
 101          unsigned char showTrackSquare_Down(unsigned char x, unsigned char y, unsigned char direction){
 102   1        signed char i,j;
 103   1        unsigned char data temptrack[6],aa[6];
 104   1        unsigned char data *pTrack =trackSquare;
 105   1        unsigned char data *pTemp = temptrack;
 106   1        unsigned char row;
 107   1        for(i = 0; i < 6; i++)
 108   1          temptrack[i] = *pTrack++;
 109   1      
 110   1        for(i = 0; i < 6; i++)
 111   1          trackSquare[i] = groundx[y+i] >> (9-x) & 0x3f; //±³¾°Êý¾ÝÐ´Èëtracksquare
 112   1      
 113   1        if(direction == 0)                               //ÏÂ½µ
 114   1          for(i = 0; i < 4; i++){
 115   2            row = tetris[i] << 1;
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 15:10:17 PAGE 3   

 116   2            if(tetris[i+1] & trackSquare[4-i] >> 1){    //tracksquare µÍ6Î»ÖÐ¼ä4Î»±£´æÊý¾Ý£¬¶øteterisµÍËÄÎ»±£´æÊ
             -ý¾Ý£¬ ÓÒÒÆÒ»Î»
 117   3              tetris_Storage(x,y,temptrack);
 118   3              square_y = 0;
 119   3              square_x = 3;
 120   3              return 1;
 121   3            }
 122   2            trackSquare[5-i] |= row;             //trackÇøÓòÓë¶íÂÞË¹·½¿éÏà»ò,±£´æÕâ´ÎÒÆ¶¯²Ù×÷µÄÊý¾Ý
 123   2          }
 124   1        else
 125   1          if(direction == 1)                             //×óÒÆ
 126   1            for(i = 0; i < 4; i++){
 127   2              row = tetris[i] << 2;
 128   2              if(tetris[i] & trackSquare[4-i] >> 2)
 129   2                return 1;
 130   2              trackSquare[4-i] |= row;
 131   2            }
 132   1          else
 133   1            if(direction == 2)                          //ÓÒÒÆ
 134   1              for(i = 0; i < 4; i++){
 135   2                row = tetris[i];
 136   2                if(tetris[i] & trackSquare[4-i])
 137   2                  return 1;
 138   2                trackSquare[4-i] |= row;
 139   2              }
 140   1            else
 141   1              return 1;
 142   1        pTemp = &temptrack[0];
 143   1        pTrack = trackSquare;
 144   1        for(i = 0; i < 6; i++){
 145   2          aa[i] = *pTrack ^ *pTemp;
 146   2          pTrack++;
 147   2          pTemp++;                            //Òì»òµÃµ½¸Ä±äÎ»´æÈëaa
 148   2        }
 149   1        if(aa[1] == 0x20)
 150   1        fillPoint(2,2,RED);
 151   1        for(i = 0; i < 6; i++){                 //ÖðÐÐÉ¨Ãè
 152   2          if(aa[i]){                           //Òì»òÖµÎªÕæ£¬¸Ä±äÑÕÉ«
 153   3            row = 0x20;
 154   3            for(j = 0; j < 6; j++){             //ÐÐÄÚÉ¨Ãè
 155   4              if(aa[i] & row ){                 //°´Î»ÅÐ¶Ï
 156   5                if(temptrack[i] & row)        //Ô­À´µÄÖµÎªÕæ£¬¸Ä³É±³¾°É«£¨ºÚÉ«£©£¬·ñÔòÌî³äÑÕÉ«
 157   5                  fillPoint(x+j+1,y+i,BLACK);
 158   5                else
 159   5                  fillPoint(x+j+1,y+i,RED);
 160   5              }
 161   4              row >>= 1;
 162   4            }
 163   3          }
 164   2        }
 165   1        return 0;
 166   1      }
 167          
 168          
 169          //ÓÎÏ·½çÃæ12X20£¬ÓÃÒ»¸ö16Î»Êý¾Ý±£´æÒ»ÐÐ£¬¸ß4Î»ÎÞÐ§£¬¹²20ÐÐ£¬20¸öÊý¾Ý
 170          
 171          
 172          void main(void)
 173          {
 174   1        unsigned char i;
 175   1        PT0 = 1;
 176   1        TMOD = 0x01;
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 15:10:17 PAGE 4   

 177   1        TH0 = 0x3C;
 178   1        TL0 = 0xB0;
 179   1        EA = 1;
 180   1        IT0 = 0;
 181   1        IT1 = 0;
 182   1        EX0 = 1;
 183   1        EX1 = 1;
 184   1        ET0 = 1;
 185   1        TR0 = 1;
 186   1        P1 = 0x0f;
 187   1        for(i = 0; i < 20; i++){
 188   2          groundx[i] = 0xc000;
 189   2          Area[i]=0xc000;
 190   2        }
 191   1      
 192   1      
 193   1        groundx[19] = 0xffff;
 194   1        Area[19] = 0xffff;
 195   1        //Area[19] = 0xffff;
 196   1        lcd_initial(); //Òº¾§ÆÁ³õÊ¼»¯
 197   1        bl=1;//±³¹â²ÉÓÃIO¿ØÖÆ£¬Ò²¿ÉÒÔÖ±½Ó½Óµ½¸ßµçÆ½³£ÁÁ
 198   1        //LCD_Clear(BLACK);   //ºÚÉ«
 199   1      
 200   1        //print_Tetris(square_x+1,6,0x88c0,YELLOW);
 201   1        delay(500);
 202   1        trackSquare_Read(square_x,square_y);
 203   1      
 204   1        while(1)
 205   1        {
 206   2          if(Down_Flag){
 207   3            trackSquare_Read(square_x,square_y);
 208   3            if(!showTrackSquare_Down(square_x, square_y, 0)){
 209   4              trackSquare_Write(square_x,square_y);
 210   4            }
 211   3            else{
 212   4              for(i = 0; i < 20; i++)
 213   4              Area[i]=groundx[i];
 214   4            }
 215   3            square_y++;
 216   3            Down_Flag = 0;
 217   3          }
 218   2          if(!Left && Move_flag){
 219   3            delay(20);
 220   3            if(!Left){
 221   4              trackSquare_Read(square_x,square_y);
 222   4              if(!showTrackSquare_Down(square_x, square_y, 1)){
 223   5                trackSquare_Write(square_x,square_y);
 224   5                square_x--;
 225   5              }
 226   4            }
 227   3          }
 228   2          if(!Right && Move_flag){
 229   3            delay(20);
 230   3            if(!Right){
 231   4              trackSquare_Read(square_x,square_y);
 232   4              if(!showTrackSquare_Down(square_x, square_y, 2)){
 233   5                trackSquare_Write(square_x,square_y);
 234   5                square_x++;
 235   5              }
 236   4            }
 237   3          }
 238   2        }
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 15:10:17 PAGE 5   

 239   1      
 240   1      }
 241          
 242          void Timer0() interrupt 1
 243          {
 244   1        TH0 = 0x3C;
 245   1        TL0 = 0xB0;
 246   1        EA = 0;
 247   1        count++;
 248   1        if(count <= 24)
 249   1          Move_flag = 1;
 250   1        else
 251   1          Move_flag = 0;
 252   1      
 253   1        if(count >= 30){          //¶¨Ê±1.5s
 254   2          count = 0;
 255   2          Down_Flag = 1;
 256   2        }
 257   1        EA = 1;
 258   1      }
 259          
 260          /*
 261          void Int0() interrupt 0
 262          {
 263            EA = 0;
 264            delay(10);
 265            if(P3^2 == 0){
 266              trackSquare_Read(square_x,square_y);
 267              showTrackSquare_Down(square_x, square_y, 2 );
 268              trackSquare_Write(square_x,square_y);
 269              square_x++;
 270            }
 271            EA = 1;
 272          }
 273          void Int1() interrupt 2
 274          {
 275            EA = 0;
 276            delay(10);
 277            if(P3^3 == 0){
 278              trackSquare_Read(square_x,square_y);
 279              showTrackSquare_Down(square_x, square_y, 2 );
 280              trackSquare_Write(square_x,square_y);
 281              square_x++;
 282            }
 283            EA = 1;
 284          }
 285          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2298    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     80    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16      60
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
