C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 22:45:50 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE ST7735_TFT
OBJECT MODULE PLACED IN .\Objects\st7735_TFT.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil_v5\C51\BIN\C51.EXE st7735_TFT.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEX
                    -TEND PRINT(.\Listings\st7735_TFT.lst) TABS(2) OBJECT(.\Objects\st7735_TFT.obj)

line level    source

   1          #include <BasicSet.c>
   2          #define TFT_Width       128
   3          #define TFT_Height      160
   4          
   5          unsigned int xdata Area[20];
   6          unsigned int xdata groundx[20];
   7          unsigned char data trackSquare[6];
   8          unsigned char data tetris[5] = {0x00,0x06,0x04,0x04,0};       //µÍËÄÎ»´æÐÐÊý¾Ý
   9          unsigned char count = 1, Down_Flag = 0, Move_flag = 0;
  10          unsigned char square_x = 6, square_y = 0, rotate = 0;
  11          unsigned int code tetrisData[6][4] = {
  12            {0x0c88,0x08e0,0x0226,0x0e20},
  13            {0x06c0,0x08c4,0x06c0,0x08c4},
  14            {0x0c60,0x04c8,0x0c60,0x04c8},
  15            {0x088c,0x02e0,0x0622,0x0e80},
  16            {0x0e40,0x0464,0x04e0,0x04c4},
  17            {0x0660,0x0660,0x0660,0x0660}
  18          };
  19          unsigned int code *pTetris = tetrisData[0];
  20          sbit Left = P1^3;
  21          sbit Right = P1^2;
  22          sbit Rota = P1^1;
  23          sbit fast = P1^0;
  24          void fillRectangle(unsigned char x, unsigned char y, unsigned char w, unsigned char h, unsigned int color)
             -{
  25   1        if((x >= TFT_Width) || (y >= TFT_Height))
  26   1          return;
  27   1        if((x + w - 1) >= TFT_Width)
  28   1          w = TFT_Width  - x;
  29   1        if((y + h - 1) >= TFT_Height)
  30   1          h = TFT_Height - y;
  31   1        Lcd_SetRegion(x, y, x+w-1, y+h-1);
  32   1        for(y = h; y > 0; y--) {
  33   2          for(x = w; x > 0; x--) {
  34   3            Lcd_WriteData_16(color);
  35   3          }
  36   2        }
  37   1      }
  38          // 8X8 square
  39          void fillPoint(unsigned char x, unsigned char y, unsigned int color ) {
  40   1        unsigned char i;
  41   1        x *= 8;
  42   1        y *= 8;
  43   1        Lcd_SetRegion(x, y, x+7, y+7);
  44   1        for(i = 64; i > 0; i-- )
  45   1          Lcd_WriteData_16(color);
  46   1      }
  47          //ÏÔÊ¾¶íÂÞË¹·½¿é
  48          void print_Tetris(unsigned char x, unsigned char y, unsigned int cube, unsigned int color){
  49   1        unsigned char row, i,bit_row,j;
  50   1        for(i = 0; i < 4; i++){               //4ÐÐ
  51   2          row = cube & 0x0f;                  //È¡³öµÍ4Î»±£´æÔÚrowÖÐ
  52   2          cube >>= 4;
  53   2          bit_row = 0x08;
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 22:45:50 PAGE 2   

  54   2          for(j=0; j < 4; j++){
  55   3            if(row & bit_row)                 //°´Î»ÅÐ¶Ï£¬ÏÔÊ¾Ò»ÐÐ
  56   3              fillPoint(x+j,y+3-i,color);     //ÏÈÏÔÊ¾Êý¾ÝµÄµÍ4Î»£¬yÖµ·´¶ø×î´ó
  57   3            bit_row >>= 1;
  58   3          }
  59   2        }
  60   1      }
  61          
  62          //Êý¾Ý´¢´æ½á¹¹£ºÒ»¸ö16Î»intÀàÐÍ´ú±íÒ»ÐÐ
  63          //¸ßÎ»Îª1´ú±í×óÇ½±Ú£¬µÍÈýÎ»ÖÃ1´ú±íÓÒÇ½±Ú
  64          /*  Ç½    1  2  3  4  5  6  7  8  9  10 11   Ç½14
  65              11 |  x  x  x  x  x  x  x  x  x  x  x  | 111      0xc007
  66          */
  67          void trackSquare_Read(unsigned char x, unsigned char y){
  68   1        unsigned int xdata *p = Area;
  69   1        unsigned char i;
  70   1        p += y;           //Êý¾Ý¿ªÊ¼ÐÐ
  71   1        for(i = 0; i < 6; i++){
  72   2          trackSquare[i] = (*p >> (9-x)); //È¡³ö6Î»Êý¾Ý£¬ÓÒÒÆ 14-6+1-x=9-x
  73   2          p++;
  74   2        }
  75   1      }
  76          
  77          void trackSquare_Write(unsigned char x, unsigned char y){
  78   1        unsigned int xdata *p = Area;
  79   1        unsigned char i;
  80   1        unsigned int a;
  81   1        p += y;
  82   1        for(i = 0; i < 6; i++ ){
  83   2          a = trackSquare[i];
  84   2          a <<= (9-x);
  85   2          *p = a;
  86   2          p++;
  87   2        }
  88   1      
  89   1      }
  90          void tetris_Storage(unsigned char x, unsigned char y, unsigned char *p){
  91   1        unsigned int xdata *pgroundx = groundx;
  92   1        unsigned char i;
  93   1        unsigned int a;
  94   1        pgroundx += (y);
  95   1        for(i = 0; i < 6; i++ ){
  96   2          a = *p & 0x3f;                   //ÆÁ±Î¸ßÁ½Î»
  97   2          a <<= (9-x);
  98   2          *pgroundx |= a;                  //Ð´ÈëÉÏÒ»´ÎtracksquareÖÐµÄÊý¾Ý
  99   2          p++;
 100   2          pgroundx++;
 101   2        }
 102   1      /*  a = 0x8000;
 103   1        for(i = 0; i < 16;i++){
 104   1          if(groundx[16] & a)
 105   1            fillPoint(i, 0, RED);
 106   1          a >>= 1;
 107   1        }
 108   1      */
 109   1      }
 110          
 111          //Show trackSquare
 112          unsigned char showTrackSquare_Down(unsigned char x, unsigned char y, unsigned char direction){
 113   1        signed char i,j;
 114   1        unsigned char data temptrack[6],aa[6];
 115   1        unsigned char data *pTrack =trackSquare;
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 22:45:50 PAGE 3   

 116   1        unsigned char data *pTemp = temptrack;
 117   1        unsigned char row;
 118   1        unsigned int  row_int;
 119   1        for(i = 0; i < 6; i++)
 120   1          temptrack[i] = *pTrack++;
 121   1      
 122   1        for(i = 0; i < 6; i++)
 123   1          trackSquare[i] = groundx[y+i] >> (9-x) & 0x3f; //±³¾°Êý¾ÝÐ´Èëtracksquare
 124   1      
 125   1        if(direction == 0)                               //ÏÂ½µ
 126   1          for(i = 0; i < 4; i++){
 127   2            row = tetris[i] << 1;
 128   2            if(tetris[i+1] & trackSquare[4-i] >> 1){    //tracksquare µÍ6Î»ÖÐ¼ä4Î»±£´æÊý¾Ý£¬¶øteterisµÍËÄÎ»±£´æÊ
             -ý¾Ý£¬ ÓÒÒÆÒ»Î»
 129   3              tetris_Storage(x,y,temptrack);
 130   3              square_y = 0;
 131   3              square_x = 3;
 132   3              return 1;
 133   3            }
 134   2            trackSquare[5-i] |= row;             //trackÇøÓòÓë¶íÂÞË¹·½¿éÏà»ò,±£´æÕâ´ÎÒÆ¶¯²Ù×÷µÄÊý¾Ý
 135   2          }
 136   1        else
 137   1          if(direction == 1)                             //×óÒÆ
 138   1            for(i = 0; i < 4; i++){
 139   2              row = tetris[i] << 2;
 140   2              if(tetris[i] & trackSquare[4-i] >> 2)
 141   2                return 1;
 142   2              trackSquare[4-i] |= row;
 143   2            }
 144   1          else
 145   1            if(direction == 2)                          //ÓÒÒÆ
 146   1              for(i = 0; i < 4; i++){
 147   2                row = tetris[i];
 148   2                if(tetris[i] & trackSquare[4-i])
 149   2                  return 1;
 150   2                trackSquare[4-i] |= row;
 151   2              }
 152   1            else
 153   1              if(direction == 3){                     //Ðý×ª
 154   2                row_int = *(pTetris + rotate);
 155   2                rotate++;
 156   2                if(rotate > 3)
 157   2                  rotate = 0;
 158   2                for(i = 0; i < 4; i++){
 159   3                  tetris[3-i] = row_int & 0x0f;
 160   3                  row_int >>= 4;
 161   3                }                                     //Ð´Èëtetris
 162   2                for(i = 0; i < 4; i++){
 163   3                  row = tetris[i] << 1;
 164   3                  if(tetris[i] & trackSquare[4-i] >> 1){   //ÅÐ¶ÏÊÇ·ñ¿ÉÒÔÐý×ª
 165   4                    rotate--;
 166   4                    row_int = *(pTetris + rotate);
 167   4                    for(i = 0; i < 4; i++){
 168   5                      tetris[3-i] = row_int & 0x0f;
 169   5                      row_int >>= 4;
 170   5                    }
 171   4                    return 1;
 172   4                  }
 173   3                  trackSquare[4-i] |= row;
 174   3                }
 175   2              }
 176   1              else
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 22:45:50 PAGE 4   

 177   1                return 1;
 178   1        pTemp = &temptrack[0];
 179   1        pTrack = trackSquare;
 180   1        for(i = 0; i < 6; i++){
 181   2          aa[i] = *pTrack ^ *pTemp;
 182   2          pTrack++;
 183   2          pTemp++;                            //Òì»òµÃµ½¸Ä±äÎ»´æÈëaa
 184   2        }
 185   1      
 186   1        for(i = 0; i < 6; i++){                 //ÖðÐÐÉ¨Ãè
 187   2          if(aa[i]){                           //Òì»òÖµÎªÕæ£¬¸Ä±äÑÕÉ«
 188   3            row = 0x20;
 189   3            for(j = 0; j < 6; j++){             //ÐÐÄÚÉ¨Ãè
 190   4              if(aa[i] & row ){                 //°´Î»ÅÐ¶Ï
 191   5                if(temptrack[i] & row)        //Ô­À´µÄÖµÎªÕæ£¬¸Ä³É±³¾°É«£¨ºÚÉ«£©£¬·ñÔòÌî³äÑÕÉ«
 192   5                  fillPoint(x+j+1,y+i,BLACK);
 193   5                else
 194   5                  fillPoint(x+j+1,y+i,RED);
 195   5              }
 196   4              row >>= 1;
 197   4            }
 198   3          }
 199   2        }
 200   1        return 0;
 201   1      }
 202          
 203          
 204          //ÓÎÏ·½çÃæ12X20£¬ÓÃÒ»¸ö16Î»Êý¾Ý±£´æÒ»ÐÐ£¬¸ß4Î»ÎÞÐ§£¬¹²20ÐÐ£¬20¸öÊý¾Ý
 205          
 206          
 207          void main(void)
 208          {
 209   1        unsigned char i;
 210   1        PT0 = 1;
 211   1        TMOD = 0x01;
 212   1        TH0 = 0x3C;
 213   1        TL0 = 0xB0;
 214   1        EA = 1;
 215   1        ET0 = 1;
 216   1        TR0 = 1;                  //´ò¿ª¶¨Ê±Æ÷0£¬¶¨Ê±50ms
 217   1        P1 = 0x0f;                //¾ØÕó¼üÅÌ½ÓP1¿Ú£¬¸³³õÖµ
 218   1        for(i = 0; i < 20; i++){
 219   2          groundx[i] = 0xc007;
 220   2          Area[i]=0xc007;
 221   2        }
 222   1      
 223   1        groundx[19] = 0xffff;
 224   1        Area[19] = 0xffff;
 225   1        //Area[19] = 0xffff;
 226   1        lcd_initial(); //Òº¾§ÆÁ³õÊ¼»¯
 227   1        bl=1;//±³¹â²ÉÓÃIO¿ØÖÆ£¬Ò²¿ÉÒÔÖ±½Ó½Óµ½¸ßµçÆ½³£ÁÁ
 228   1        //LCD_Clear(BLACK);   //ºÚÉ«
 229   1      
 230   1        //print_Tetris(square_x+1,6,0x88c0,YELLOW);
 231   1        delay(500);
 232   1        trackSquare_Read(square_x,square_y);
 233   1      
 234   1        while(1)
 235   1        {
 236   2          if(Down_Flag){                                      //downflag¶¨Ê±Æ÷T0¼ÆÊ±1.5s´¥·¢ÖÃÎ»£¬·½¿éÏÂ½µ
 237   3            trackSquare_Read(square_x,square_y);              //¶ÁÈ¡×·×ÙÇøÓòÊý¾Ýµ½Tracksquare
 238   3            if(!showTrackSquare_Down(square_x, square_y, 0)){ //ÅÐ¶ÏÊÇ·ñ´¥µ×£¬´¥µ×Ôò²»Ð´Èë×·×ÙÊý¾Ý£¬ÓÉ¸Ãº¯Êý½«Êý
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 22:45:50 PAGE 5   

             -¾ÝÐ´Èë±³¾°ÇøÓò
 239   4              trackSquare_Write(square_x,square_y);           //Ã»ÓÐ´¥µ×£¬TracksquareÊý¾ÝÐ´Èë×·×ÙÇøÓò
 240   4              square_y++;                   //ÏÂÒÆÒ»¸ñ
 241   4            }
 242   3            else{
 243   4              for(i = 0; i < 20; i++)
 244   4              Area[i]=groundx[i];         //Í¬²½Êý¾Ý
 245   4            }
 246   3            Down_Flag = 0;                //Çå³ýÏÂ½µ±êÖ¾
 247   3          }
 248   2          if(!Left && Move_flag){         //×óÒÆÅÐ¶Ï£¬Í¬Ê±ÅÐ¶ÏÊÇ·ñÔÊÐíÒÆ¶¯²Ù×÷£¬moveflagÓÉT0¿ØÖÆ
 249   3            delay(20);
 250   3            if(!Left){                    //ÑÓÊ±Ïû¶¶£¬ÔÙ´ÎÅÐ¶Ï
 251   4              trackSquare_Read(square_x,square_y);
 252   4              if(!showTrackSquare_Down(square_x, square_y, 1)){
 253   5                trackSquare_Write(square_x,square_y);
 254   5                square_x--;
 255   5              }
 256   4            }
 257   3          }
 258   2          if(!Right && Move_flag){        //ÓÒÒÆÅÐ¶Ï
 259   3            delay(20);
 260   3            if(!Right){
 261   4              trackSquare_Read(square_x,square_y);
 262   4              if(!showTrackSquare_Down(square_x, square_y, 2)){
 263   5                trackSquare_Write(square_x,square_y);
 264   5                square_x++;
 265   5              }
 266   4            }
 267   3          }
 268   2          if(!Rota && Move_flag){        //Ðý×ªÅÐ¶Ï
 269   3            delay(20);
 270   3            if(!Rota){
 271   4              trackSquare_Read(square_x,square_y);
 272   4              if(!showTrackSquare_Down(square_x, square_y, 3))
 273   4                trackSquare_Write(square_x,square_y);
 274   4            }
 275   3          }
 276   2          if(!fast){
 277   3            delay(20);
 278   3            if(!fast)
 279   3              Down_Flag = 1;
 280   3          }
 281   2        }
 282   1      
 283   1      }
 284          
 285          void Timer0() interrupt 1
 286          {
 287   1        TH0 = 0x3C;
 288   1        TL0 = 0xB0;                //¶¨Ê±50ms
 289   1        count++;
 290   1        if(count <= 22)           //Ç°22*50=1.1s¿ÉÒÔ½øÐÐ×óÓÒÒÆ¶¯²Ù×÷
 291   1          Move_flag = 1;
 292   1        else
 293   1          Move_flag = 0;
 294   1      
 295   1        if(count >= 30){          //¶¨Ê±1.5s
 296   2          count = 0;
 297   2          Down_Flag = 1;
 298   2        }
 299   1      }
C51 COMPILER V9.59.0.0   ST7735_TFT                                                        04/21/2019 22:45:50 PAGE 6   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2499    ----
   CONSTANT SIZE    =     48    ----
   XDATA SIZE       =     80    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19      60
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
